tools:
  - name: request_access
    alias: request_access
    description: A tool to request access, generating an IAM policy based on a description and creating an approval request in SQLite and sending a webhook notification.
    type: python
    content: |
      import os
      import sqlite3
      import sys
      from datetime import datetime, timedelta
      import requests
      from litellm import completion

      USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')
      SLACK_CHANNEL_ID = os.getenv('SLACK_CHANNEL_ID')
      SLACK_THREAD_TS = os.getenv('SLACK_THREAD_TS')
      KUBIYA_USER_ORG = os.getenv('KUBIYA_USER_ORG')
      KUBIYA_API_KEY = os.getenv('KUBIYA_API_KEY')
      APPROVAL_SLACK_CHANNEL = os.getenv('APPROVAL_SLACK_CHANNEL')
      OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
      OPENAI_API_BASE = os.getenv('OPENAI_API_BASE')

      purpose = "{{.purpose}}"
      ttl = "{{.ttl}}"
      policy_name = "{{.policy_name}}"
      permission_set_name = "{{.permission_set_name}}"
      policy_description = "{{.policy_description}}"

      def generate_policy(policy_description: str) -> str:
          messages = [{"content": policy_description, "role": "user"}]
          try:
              response = completion(model="gpt-4o", messages=messages)
              completion = response['choices'][0]['message']['content']
              # make sure we only return the policy
              # find JSON start and end
              start = completion.find('{')
              end = completion.rfind('}')
              return completion[start:end+1]
          except Exception as e:
              print(f"Policy generation failed: {e}")
              sys.exit(1)

      policy_json = generate_policy(policy_description)

      try:
          if ttl[-1] == 'm':
              ttl_minutes = int(ttl[:-1])
          elif ttl[-1] == 'h':
              ttl_minutes = int(ttl[:-1]) * 60
          elif ttl[-1] == 'd':
              ttl_minutes = int(ttl[:-1]) * 60 * 24
          else:
              print("Error: Unsupported TTL format. Use 'm', 'h', or 'd'.")
              sys.exit(1)
      except ValueError:
          print("Error: Invalid TTL format.")
          sys.exit(1)

      approval_request = {
          'user_email': USER_EMAIL,
          'purpose': purpose,
          'ttl_minutes': ttl_minutes,
          'policy_name': policy_name,
          'permission_set_name': permission_set_name,
          'policy_json': policy_json,
          'requested_at': datetime.utcnow(),
          'expires_at': datetime.utcnow() + timedelta(minutes=ttl_minutes),
          'slack_channel_id': SLACK_CHANNEL_ID,
          'slack_thread_ts': SLACK_THREAD_TS,
          'approved': 'pending'
      }

      conn = sqlite3.connect('/sqlite_data/approval_requests.db')
      c = conn.cursor()
      c.execute('''CREATE TABLE IF NOT EXISTS approvals
                   (user_email text, purpose text, ttl_minutes int, policy_name text, permission_set_name text, policy_json text, requested_at text, expires_at text, slack_channel_id text, slack_thread_ts text, approved text)''')

      c.execute("INSERT INTO approvals (user_email, purpose, ttl_minutes, policy_name, permission_set_name, policy_json, requested_at, expires_at, slack_channel_id, slack_thread_ts, approved) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (approval_request['user_email'], approval_request['purpose'], 
                 approval_request['ttl_minutes'], approval_request['policy_name'], approval_request['permission_set_name'], 
                 approval_request['policy_json'], approval_request['requested_at'], approval_request['expires_at'], 
                 approval_request['slack_channel_id'], approval_request['slack_thread_ts'], 'pending'))

      conn.commit()
      conn.close()

      entry = {
          "user_email": USER_EMAIL,
          "purpose": purpose,
          "ttl_minutes": ttl,
          "policy_name": policy_name,
          "permission_set_name": permission_set_name,
          "policy_json": policy_json
      }

      # Create and send webhook
      prompt = f"User {USER_EMAIL} just asked for approval to get a temporary access to {permission_set_name} for {ttl} minutes. The purpose is: {purpose}.\n\nBelow is least privilaged policy {USER_EMAIL} has asked for:\n\n{policy_json}\n\nAsk if to approve or reject this request - here's the full request information:\n\n{entry} - FIRST THING you should do is ask if this is a valid request and if you should approve it. DO NOT RUN ANY COMMANDS UNTIL YOU HAVE VERIFIED THE REQUEST."
      
      payload = {
          "agent_id": os.getenv('KUBIYA_AGENT_UUID'),
          "communication": {
              "destination": APPROVAL_SLACK_CHANNEL,
              "method": "Slack"
          },
          "created_at": datetime.utcnow().isoformat() + "Z",
          "created_by": USER_EMAIL,
          "name": "Approval Request",
          "org": KUBIYA_USER_ORG,
          "prompt": prompt,
          "source": "Triggered by an access request (Agent)",
          "updated_at": datetime.utcnow().isoformat() + "Z"
      }

      response = requests.post(
          "https://api.kubiya.ai/api/v1/event",
          headers={
              'Content-Type': 'application/json',
              'Authorization': f'UserKey {KUBIYA_API_KEY}'
          },
          json=payload
      )

      if response.status_code < 300:
          print(f"WAITING: Request submitted succesfully and has been sent to an approver. Waiting for approval.")
          event_response = response.json()
          webhook_url = event_response.get("webhook_url")
          if (webhook_url):
              requests.post(
                  webhook_url,
                  headers={'Content-Type': 'application/json'},
                  json=payload
              )
          else:
              print("Error: No webhook URL returned in the response.")
      else:
          print(f"Error: {response.status_code} - {response.text}")

    args:
      purpose:
        description: The purpose of the request
        required: true
      ttl:
        description: "Time to live for the request (format: 1m, 1h, 1d - only minutes (m), hours (h), and days (d) are supported)"
        required: true
      policy_name:
        description: The name of the customer managed policy to create
        required: true
      permission_set_name:
        description: The name of the permission set to update
        required: true
      policy_description:
        description: "A NATURAL LANGUAGE description of the policy to generate - this will be used to generate the policy JSON - should be a precise description of the permissions required, eg: 'Allow the user to read from the S3 bucket named 'my-bucket' and write to the DynamoDB table named 'my-table'.'"
        required: true
    dependencies: |
      litellm
      requests
    env:
      - KUBIYA_USER_EMAIL
      - SLACK_CHANNEL_ID
      - SLACK_THREAD_TS
      - KUBIYA_AGENT_UUID
      - KUBIYA_USER_ORG
      - KUBIYA_API_KEY
      - APPROVAL_SLACK_CHANNEL
      - AWS_PROFILE
      - OPENAI_API_KEY
      - OPENAI_API_BASE
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data

  - name: approve_request
    alias: approve_request
    description: Allows admins to approve or reject access requests - upon approval, a task is scheduled to delete the permission set after the TTL
    type: python
    content: |
      import os
      import sqlite3
      import sys
      from datetime import datetime, timedelta
      import requests

      APPROVER_USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')
      APPROVING_USERS = os.getenv('APPROVING_USERS', '').split(',')
      SLACK_API_TOKEN = os.getenv('SLACK_API_TOKEN')
      KUBIYA_API_KEY = os.getenv('KUBIYA_API_KEY')

      if not APPROVER_USER_EMAIL:
          print("Missing APPROVER_USER_EMAIL environment variable")
          sys.exit(1)

      if "{{.approval_action}}" not in ['approved', 'rejected']:
          print("Error: Invalid approval action. Use 'approved' or 'rejected'.")
          sys.exit(1)

      if APPROVER_USER_EMAIL not in APPROVING_USERS:
          print(f"User {APPROVER_USER_EMAIL} is not authorized to approve this request")
          sys.exit(1)

      request = "{{.request}}"
      user_email = "{{.user_email}}"
      approval_action = "{{.approval_action}}"

      conn = sqlite3.connect('/sqlite_data/approval_requests.db')
      c = conn.cursor()

      # Remove expired requests
      c.execute("DELETE FROM approvals WHERE expires_at < ?", (datetime.utcnow().isoformat(),))
      conn.commit()

      c.execute("SELECT * FROM approvals WHERE user_email=? AND policy_name=? AND approved='pending'", (user_email, request))
      approval_request = c.fetchone()

      if not approval_request:
          print(f"No pending approval request found for user {user_email} and request {request}")
          sys.exit(1)

      c.execute("UPDATE approvals SET approved=? WHERE user_email=? AND policy_name=?", (approval_action, user_email, request))
      conn.commit()
      conn.close()

      print(f"Approval request for user {user_email} and request {request} has been {approval_action}")

      if approval_action == "approved":
          # Schedule task for deletion
          duration = f"{approval_request[2]}m"
          task_payload = {
              "execution_delay": duration,
              "task_description": "delete_permission_set",
              "channel_id": approval_request[8],
              "user_email": user_email,
              "organization_name": os.getenv("KUBIYA_USER_ORG"),
              "agent": os.getenv("KUBIYA_AGENT_PROFILE")
          }
          response = requests.post(
              'https://api.kubiya.ai/api/v1/scheduled_tasks',
              headers={
                  'Authorization': f'UserKey {KUBIYA_API_KEY}',
                  'Content-Type': 'application/json'
              },
              json=task_payload
          )

          if response.status_code < 300:
              print(f"Task scheduled successfully. Response: {response.text}")
          else:
              print(f"Error: {response.status_code} - {response.text}")

      slack_channel_id = approval_request[8]
      slack_thread_ts = approval_request[9]

      # Get permalink
      permalink_response = requests.get(
          "https://slack.com/api/chat.getPermalink",
          params={
              'channel': slack_channel_id,
              'message_ts': slack_thread_ts
          },
          headers={
              'Authorization': f'Bearer {SLACK_API_TOKEN}'
          }
      )
      permalink = permalink_response.json().get("permalink")

      action_emoji = ":white_check_mark:" if approval_action == "approved" else ":x:"
      action_text = "approved" if approval_action == "approved" else "rejected"
      approver_text = f"<@{APPROVER_USER_EMAIL}> {action_text} this request {action_emoji}"

      slack_payload = {
          "channel": slack_channel_id,
          "text": f"<@{user_email}>, your request has been {approval_action}.",
          "blocks": [
              {
                  "type": "section",
                  "text": {
                      "type": "mrkdwn",
                      "text": f"*Request {approval_action}* {action_emoji}\n*User:* <@{user_email}>\n*Purpose:* {approval_request[1]}\n*Access:* {approval_request[3]} for {approval_request[2]}\n*Approved by:* {approver_text}\n<{permalink}|View original conversation>"
                  }
              },
              {
                  "type": "actions",
                  "elements": [
                      {
                          "type": "button",
                          "text": {
                              "type": "plain_text",
                              "text": "View Request"
                          },
                          "url": permalink
                      }
                  ]
              }
          ],
          "thread_ts": slack_thread_ts
      }

      slack_response = requests.post(
          "https://slack.com/api/chat.postMessage",
          headers={
              'Content-Type': 'application/json',
              'Authorization': f'Bearer {SLACK_API_TOKEN}'
          },
          json=slack_payload
      )

      if slack_response.status_code < 300:
          print(f"All done! Slack notification sent successfully. Response: {slack_response.text}")
      else:
          print(f"Error sending Slack notification: {slack_response.status_code} - {slack_response.text}")

    args:
      request:
        description: The request being approved or rejected
        required: true
      user_email:
        description: The email of the user making the request
        required: true
      approval_action:
        description: Approval action (approved or rejected)
        required: true
        # TODO:: Add validation for this field 
    env:
      - KUBIYA_USER_EMAIL
      - APPROVING_USERS
      - SLACK_API_TOKEN
      - KUBIYA_API_KEY
    dependencies: |
      requests
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data

  - name: view_requests
    alias: view_requests
    description: A tool to view current access requests from SQLite database and send a detailed Slack Block Kit message
    type: python
    content: |
      import os
      import sqlite3
      import json
      import requests
      import sys

      SLACK_API_TOKEN = os.getenv('SLACK_API_TOKEN')
      SLACK_CHANNEL_ID = os.getenv('SLACK_CHANNEL_ID')
      SLACK_THREAD_TS = os.getenv('SLACK_THREAD_TS')
      APPROVING_USERS = os.getenv('APPROVING_USERS', '').split(',')
      USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')

      if not SLACK_API_TOKEN or not SLACK_CHANNEL_ID or not SLACK_THREAD_TS or not USER_EMAIL:
          print("Missing required environment variables")
          sys.exit(1)

      if USER_EMAIL not in APPROVING_USERS:
          print(f"Permission denied! User {USER_EMAIL} is not authorized to view access requests.")
          sys.exit(1)

      conn = sqlite3.connect('/sqlite_data/approval_requests.db')
      c = conn.cursor()

      c.execute("SELECT * FROM approvals WHERE approved='pending'")
      requests = c.fetchall()
      conn.close()

      requests_list = []
      for request in requests:
          request_data = {
              "user_email": request[0],
              "purpose": request[1],
              "ttl_minutes": request[2],
              "policy_name": request[3],
              "permission_set_name": request[4],
              "policy_json": request[5],
              "requested_at": request[6],
              "expires_at": request[7],
              "slack_channel_id": request[8],
              "slack_thread_ts": request[9],
              "approved": request[10]
          }
          requests_list.append(request_data)

      blocks = [
          {
              "type": "section",
              "text": {
                  "type": "mrkdwn",
                  "text": ":sparkles: *Pending Access Requests* :sparkles:"
              }
          },
          {
              "type": "divider"
          }
      ]

      for req in requests_list:
          block = {
              "type": "section",
              "text": {
                  "type": "mrkdwn",
                  "text": (
                      f":bust_in_silhouette: *User:* `{req['user_email']}`\n"
                      f":memo: *Purpose:* `{req['purpose']}`\n"
                      f":hourglass_flowing_sand: *TTL:* `{req['ttl_minutes']} minutes`\n"
                      f":lock: *Policy Name:* `{req['policy_name']}`\n"
                      f":key: *Permission Set:* `{req['permission_set_name']}`\n"
                      f":calendar: *Requested At:* `{req['requested_at']}`\n"
                      f":alarm_clock: *Expires At:* `{req['expires_at']}`\n"
                      f":question: *Status:* `{req['approved']}`"
                  )
              }
          }
          blocks.append(block)
          blocks.append({"type": "divider"})

      payload = {
          "channel": SLACK_CHANNEL_ID,
          "thread_ts": SLACK_THREAD_TS,
          "blocks": blocks
      }

      response = requests.post(
          "https://slack.com/api/chat.postMessage",
          headers={
              'Content-Type': 'application/json',
              'Authorization': f'Bearer {SLACK_API_TOKEN}'
          },
          json=payload
      )

      if response.status_code < 300:
          print(f"Slack notification sent successfully. Response: {response.text}")
      else:
          print(f"Error sending Slack notification: {response.status_code} - {response.text}")

    env:
      - SLACK_API_TOKEN
      - SLACK_CHANNEL_ID
      - SLACK_THREAD_TS
      - APPROVING_USERS
      - KUBIYA_USER_EMAIL
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data
    dependencies: |
      requests
