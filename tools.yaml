tools:
  - name: request_access
    alias: request_access
    description: A tool to request access, creating an approval request in SQLite
    type: python
    content: |
      import os
      import sqlite3
      import sys
      from datetime import datetime, timedelta

      USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')

      if not USER_EMAIL:
          print("Missing KUBIYA_USER_EMAIL environment variable")
          sys.exit(1)

      purpose = "{{.purpose}}"
      ttl_minutes = int("{{.ttl}}")
      policy_name = "{{.policy_name}}"
      permission_set_name = "{{.permission_set_name}}"
      policy_json = "{{.policy_json}}"

      approval_request = {
          'user_email': USER_EMAIL,
          'purpose': purpose,
          'ttl_minutes': ttl_minutes,
          'policy_name': policy_name,
          'permission_set_name': permission_set_name,
          'policy_json': policy_json,
          'requested_at': datetime.utcnow(),
          'expires_at': datetime.utcnow() + timedelta(minutes=ttl_minutes)
      }

      conn = sqlite3.connect('/data/approval_requests.db')
      c = conn.cursor()
      c.execute('''CREATE TABLE IF NOT EXISTS approvals
                   (user_email text, purpose text, ttl_minutes int, policy_name text, permission_set_name text, policy_json text, requested_at text, expires_at text, approved text)''')

      c.execute("INSERT INTO approvals (user_email, purpose, ttl_minutes, policy_name, permission_set_name, policy_json, requested_at, expires_at, approved) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (approval_request['user_email'], approval_request['purpose'], 
                 approval_request['ttl_minutes'], approval_request['policy_name'], approval_request['permission_set_name'], 
                 approval_request['policy_json'], approval_request['requested_at'], approval_request['expires_at'], 'pending'))

      conn.commit()
      conn.close()

      print(f"Approval request created for {USER_EMAIL} with purpose: {purpose}")

    args:
      purpose:
        description: The purpose of the request
        required: true
      ttl:
        description: Time to live for the request in minutes
        required: true
      policy_name:
        description: The name of the customer managed policy to create
        required: true
      permission_set_name:
        description: The name of the permission set to update
        required: true
      policy_json:
        description: The JSON policy to apply to the customer managed policy
        required: true
    env:
      - KUBIYA_USER_EMAIL
    with_volumes:
      - name: sqlite_data
        path: /data

  - name: check_access
    alias: check_access
    description: A tool to check if a user has access based on approved requests in SQLite
    type: python
    content: |
      import os
      import sqlite3
      import sys

      USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')

      if not USER_EMAIL:
          print("Missing KUBIYA_USER_EMAIL environment variable")
          sys.exit(1)

      purpose = "{{.purpose}}"
      policy_name = "{{.policy_name}}"
      permission_set_name = "{{.permission_set_name}}"
      policy_json = "{{.policy_json}}"
      ttl_minutes = int("{{.ttl}}")

      conn = sqlite3.connect('/data/approval_requests.db')
      c = conn.cursor()

      # Check if the table exists
      c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='approvals'")
      if not c.fetchone():
          print("The approvals table does not exist.")
          sys.exit(1)

      c.execute("SELECT * FROM approvals WHERE user_email=? AND purpose=? AND policy_name=? AND permission_set_name=? AND policy_json=? AND ttl_minutes=? AND approved='approved'",
                (USER_EMAIL, purpose, policy_name, permission_set_name, policy_json, ttl_minutes))
      approval = c.fetchone()

      conn.close()

      if not approval:
          print(f"User {USER_EMAIL} does not have access for the provided details")
          sys.exit(1)

      print(f"User {USER_EMAIL} has access")

    args:
      purpose:
        description: The purpose of the request
        required: true
      policy_name:
        description: The name of the customer managed policy to create
        required: true
      permission_set_name:
        description: The name of the permission set to update
        required: true
      policy_json:
        description: The JSON policy to apply to the customer managed policy
        required: true
      ttl:
        description: Time to live for the request in minutes
        required: true
    env:
      - KUBIYA_USER_EMAIL
    with_volumes:
      - name: sqlite_data
        path: /data

  - name: update-sso-permission-set
    description: A Python script to create a customer managed policy, attach it to an SSO permission set, update the permission set, and provision the permission set
    type: python
    alias: update-permission-set
    content: |
      import boto3
      from botocore.exceptions import ClientError
      import os
      import sys
      import configparser
      import json
      from io import StringIO
      import sqlite3
      from datetime import datetime, timedelta

      def check_user_access(user_email):
          conn = sqlite3.connect('/data/approval_requests.db')
          c = conn.cursor()
          c.execute("SELECT * FROM approvals WHERE user_email=? AND approved='approved'", (user_email,))
          approval = c.fetchone()
          conn.close()
          return approval is not None

      USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')

      if not USER_EMAIL:
          print("Missing KUBIYA_USER_EMAIL environment variable")
          sys.exit(1)

      if not check_user_access(USER_EMAIL):
          print(f"User {USER_EMAIL} does not have access to perform this action")
          sys.exit(1)

      aws_creds_content = """{{.aws_creds_content}}"""
      permission_set_name = """{{.permission_set_name}}"""
      policy_name = """{{.policy_name}}"""
      policy_json = """{{.policy_json}}"""
      ttl_minutes = int("""{{.ttl}}""")

      instance_arn = os.getenv('SSO_INSTANCE_ARN')

      if not instance_arn:
          print("Error: Environment variable SSO_INSTANCE_ARN not set.")
          sys.exit(1)

      config = configparser.ConfigParser()
      config.read_string(aws_creds_content)

      aws_access_key_id = None
      aws_secret_access_key = None
      aws_session_token = None
      region_name = None

      for section in config.sections():
          if 'aws_access_key_id' in config[section]:
              aws_access_key_id = config[section]['aws_access_key_id']
          if 'aws_secret_access_key' in config[section]:
              aws_secret_access_key = config[section]['aws_secret_access_key']
          if 'aws_session_token' in config[section]:
              aws_session_token = config[section]['aws_session_token']
          if 'region' in config[section]:
              region_name = config[section]['region']

      if not all([aws_access_key_id, aws_secret_access_key, aws_session_token, region_name]):
          print("Error: Missing required AWS credentials.")
          sys.exit(1)

      # Initialize boto3 session
      session = boto3.Session(
          aws_access_key_id=aws_access_key_id,
          aws_secret_access_key=aws_secret_access_key,
          aws_session_token=aws_session_token,
          region_name=region_name
      )

      # Initialize boto3 clients
      iam_client = session.client('iam')
      sso_admin_client = session.client('sso-admin')

      try:
          # List all permission sets and find the ARN for the given name
          response = sso_admin_client.list_permission_sets(
              InstanceArn=instance_arn
          )

          permission_set_arn = None
          for permission_set in response['PermissionSets']:
              permission_set_details = sso_admin_client.describe_permission_set(
                  InstanceArn=instance_arn,
                  PermissionSetArn=permission_set
              )
              if permission_set_details['PermissionSet']['Name'] == permission_set_name:
                  permission_set_arn = permission_set
                  break

          if not permission_set_arn:
              print(f"Error: Permission set with name '{permission_set_name}' not found.")
              sys.exit(1)

          # Create the customer managed policy
          policy_document = json.loads(policy_json)
          response = iam_client.create_policy(
              PolicyName=policy_name,
              PolicyDocument=json.dumps(policy_document)
          )
          policy_arn = response['Policy']['Arn']
          print(f"Created policy: {policy_arn}")

          # Attach the customer managed policy to the permission set
          sso_admin_client.attach_customer_managed_policy_reference_to_permission_set(
              InstanceArn=instance_arn,
              PermissionSetArn=permission_set_arn,
              CustomerManagedPolicyReference={
                  'Name': policy_name,
                  'Path': '/'
              }
          )
          print("Policy attached to permission set successfully.")

          # Update the permission set
          sso_admin_client.update_permission_set(
              InstanceArn=instance_arn,
              PermissionSetArn=permission_set_arn
          )
          print("Permission set updated successfully.")

          # Provision the permission set
          sso_admin_client.provision_permission_set(
              InstanceArn=instance_arn,
              PermissionSetArn=permission_set_arn,
              TargetType='ALL_PROVISIONED_ACCOUNTS'
          )
          print("Permission set provisioned successfully.")

          # Schedule the removal task
          schedule_time = (datetime.utcnow() + timedelta(minutes=ttl_minutes)).isoformat() + "Z"
          schedule_task(schedule_time, policy_name, permission_set_arn)

      except ClientError as e:
          print(f"Error: {e}")
      except json.JSONDecodeError as e:
          print(f"Error parsing policy JSON: {e}")

      def schedule_task(schedule_time, policy_name, permission_set_arn):
          # Here we assume there's a function to schedule a task, it should be implemented accordingly.
          # This is a placeholder for the actual scheduling implementation.
          print(f"Scheduled task to remove policy '{policy_name}' from permission set '{permission_set_arn}' at {schedule_time}")

    dependencies: |
      boto3==1.34.125
      sqlite
    args:
      aws_creds_content:
        description: Contents of the AWS credentials file
        required: true
      permission_set_name:
        description: The name of the permission set to update
        required: true
      policy_name:
        description: The name of the customer managed policy to create
        required: true
      policy_json:
        description: The JSON policy to apply to the customer managed policy
        required: true
      ttl:
        description: Time to live for the request in minutes
        required: true
    env:
      - KUBIYA_USER_EMAIL
      - SSO_INSTANCE_ARN
    with_volumes:
      - name: sqlite_data
        path: /data

  - name: approve_request
    alias: approve_request
    description: A tool to approve a request if the approver is in the admin group
    type: python
    content: |
      import os
      import sqlite3
      import sys
      from datetime import datetime

      APPROVER_USER_EMAIL = os.getenv('APPROVER_USER_EMAIL')

      if not APPROVER_USER_EMAIL:
          print("Missing APPROVER_USER_EMAIL environment variable")
          sys.exit(1)

      if APPROVER_USER_EMAIL not in os.getenv('APPROVING_USERS', '').split(','):
          print(f"User {APPROVER_USER_EMAIL} is not authorized to approve this request")
          sys.exit(1)

      request = "{{.request}}"
      user_email = "{{.user_email}}"
      approval_action = "{{.approval_action}}"

      conn = sqlite3.connect('/data/approval_requests.db')
      c = conn.cursor()

      # Remove expired requests
      c.execute("DELETE FROM approvals WHERE expires_at < ?", (datetime.utcnow().isoformat(),))
      conn.commit()

      c.execute("SELECT * FROM approvals WHERE user_email=? AND request=? AND approved='pending'", (user_email, request))
      approval_request = c.fetchone()

      if not approval_request:
          print(f"No pending approval request found for user {user_email} and request {request}")
          sys.exit(1)

      c.execute("UPDATE approvals SET approved=? WHERE user_email=? AND request=?", (approval_action, user_email, request))
      conn.commit()
      conn.close()

      print(f"Approval request for user {user_email} and request {request} has been {approval_action}")

    args:
      request:
        description: The request being approved or rejected
        required: true
        options_from:
          script: |
            import sqlite3
            conn = sqlite3.connect('/data/approval_requests.db')
            c = conn.cursor()
            c.execute("SELECT DISTINCT request FROM approvals WHERE approved='pending'")
            requests = c.fetchall()
            conn.close()
            options = [request[0] for request in requests]
            for option in options:
                print(option)
      user_email:
        description: The email of the user making the request
        required: true
        options_from:
          script: |
            import sqlite3
            conn = sqlite3.connect('/data/approval_requests.db')
            c = conn.cursor()
            c.execute("SELECT DISTINCT user_email FROM approvals WHERE approved='pending'")
            users = c.fetchall()
            conn.close()
            options = [user[0] for user in users]
            for option in options:
                print(option)
      approval_action:
        description: Approval action (approved or rejected)
        required: true
        options:
          - approved
          - rejected
    env:
      - APPROVER_USER_EMAIL
      - APPROVING_USERS
    with_volumes:
      - name: sqlite_data
        path: /data
